<!doctype html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>카드 겹침 퍼즐</title>
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --card: #1f2937;
      --accent: #60a5fa;
      --accent-strong: #38bdf8;
      --danger: #f87171;
      --success: #22c55e;
      --muted: #94a3b8;
      --glow: 0 0 0 3px rgba(96,165,250,0.55), 0 10px 30px rgba(0,0,0,0.35);
      --radius: 14px;
    }
    html {
      height: 100%;
      background: var(--bg);
      overscroll-behavior: none;
      overflow: hidden;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background: radial-gradient(circle at 20% 20%, #0b1223 0%, #0f172a 40%, #0a0f1e 100%);
      background-color: var(--bg);
      padding-top: env(safe-area-inset-top, 0px);
      padding-bottom: env(safe-area-inset-bottom, 0px);
      color: #e5e7eb;
      display: flex;
      justify-content: center;
      overflow: hidden;
      position: fixed;
      inset: 0;
      overscroll-behavior: none;
      touch-action: pan-x pan-y;
    }
    .app {
      width: min(1200px, 96vw);
      min-height: 100dvh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 12px 12px calc(16px + env(safe-area-inset-bottom, 0px));
      gap: 12px;
    }
    header {
      width: 100%;
      text-align: center;
    }
    h1 {
      margin: 0 0 6px;
      font-size: 24px;
      letter-spacing: -0.02em;
    }
    .subtitle {
      margin: 0;
      color: var(--muted);
      font-size: 14px;
    }
    .result-area {
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }
    .result-wrapper {
      background: var(--panel);
      padding: 8px;
      border-radius: var(--radius);
      box-shadow: 0 8px 24px rgba(0,0,0,0.35);
      transition: box-shadow 0.3s ease;
    }
    .result-wrapper.success {
      box-shadow: 0 0 0 4px rgba(34,197,94,0.6), 0 12px 28px rgba(34,197,94,0.35);
    }
    .result-grid {
      width: clamp(160px, 18vw, 190px);
      aspect-ratio: 3 / 5;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(5, 1fr);
      gap: 0;
      background: linear-gradient(135deg, rgba(148,163,184,0.08), rgba(148,163,184,0.02));
      border-radius: 10px;
      overflow: hidden;
      position: relative;
    }
    .result-cell {
      width: 100%;
      height: 100%;
      background: transparent;
      opacity: 0;
      transform: scale(0.98);
      transition: background 320ms ease, transform 320ms ease, opacity 320ms ease;
    }
    .result-cell.on {
      background: linear-gradient(145deg, rgba(96,165,250,0.8), rgba(56,189,248,0.85));
      opacity: 1;
      transform: scale(1);
    }
    .result-cell.on-final {
      background: linear-gradient(145deg, rgba(34,197,94,0.9), rgba(22,163,74,0.85));
      opacity: 1;
      transform: scale(1);
    }
    .result-cell.fading-out {
      opacity: 0;
      transform: scale(0.96);
    }
    .result-cell.changed {
      animation: cell-flash 360ms ease;
    }
    @keyframes cell-flash {
      0% { transform: scale(0.9); filter: brightness(1.35); }
      60% { transform: scale(1.03); filter: brightness(1.15); }
      100% { transform: scale(1); filter: brightness(1); }
    }
    .cards-area {
      width: 100%;
      background: rgba(17,24,39,0.6);
      border-radius: var(--radius);
      padding: 8px;
      box-shadow: 0 12px 30px rgba(0,0,0,0.35);
      margin-bottom: 4px;
    }
    .cards-row {
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      gap: 6px;
      width: 100%;
      justify-items: center;
      align-items: start;
    }
    .card {
      width: 90%;
      aspect-ratio: 3 / 5;
      border: 1px solid rgba(148,163,184,0.25);
      border-radius: 8px;
      background: var(--card);
      color: #e5e7eb;
      padding: 5px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: transform 160ms ease, box-shadow 160ms ease, border-color 160ms ease;
      position: relative;
      overflow: hidden;
      box-shadow: 0 6px 18px rgba(0,0,0,0.28);
      perspective: 1000px;
      -webkit-perspective: 1000px;
    }
    .card.disabled {
      cursor: not-allowed;
      filter: grayscale(0.2);
      opacity: 0.65;
    }
    .card-inner {
      position: relative;
      width: 100%;
      height: 100%;
      transform-style: preserve-3d;
      -webkit-transform-style: preserve-3d;
    }
    .card-face {
      position: absolute;
      inset: 0;
      border-radius: 8px;
      backface-visibility: hidden;
      -webkit-backface-visibility: hidden;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      gap: 2px;
      align-items: center;
      justify-content: center;
    }
    .card-face.front {
      background: var(--card);
    }
    .card-face.back {
      background: radial-gradient(circle at 20% 20%, rgba(96,165,250,0.18), rgba(31,41,55,0.9));
      display: flex;
      align-items: center;
      justify-content: center;
      transform: rotateY(180deg);
    }
    .card-back-border {
      position: absolute;
      inset: 8px;
      border-radius: 8px;
      border: 2px solid var(--accent);
      opacity: 0.9;
    }
    .card-back-star {
      width: 46%;
      aspect-ratio: 1;
      color: var(--accent);
      filter: drop-shadow(0 0 8px rgba(96,165,250,0.4));
    }
    .grid {
      width: 100%;
      max-width: 100%;
      aspect-ratio: 3 / 5;
      margin: auto;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(5, 1fr);
      gap: 2px;
    }
    .grid .cell {
      background: rgba(255,255,255,0.04);
      border-radius: 6px;
      border: 1px solid rgba(148,163,184,0.15);
      transition: background-color 150ms ease, border-color 150ms ease;
    }
    .grid .cell.filled {
      background: linear-gradient(145deg, rgba(96,165,250,0.9), rgba(56,189,248,0.85));
      border-color: rgba(56,189,248,0.6);
    }
    /* hover lift 제거 */
    .card.selected {
      border-color: var(--accent);
      box-shadow: var(--glow);
    }
    .card.selected-wrong {
      border-color: var(--danger);
      box-shadow: 0 0 0 3px rgba(248,113,113,0.5), 0 10px 24px rgba(248,113,113,0.35);
    }
    .card.hide-border {
      border-color: transparent !important;
      box-shadow: none !important;
    }
    .card.flip-surface {
      background: transparent !important;
      box-shadow: none !important;
    }
    .card-inner.animate {
      animation: flip-3d 520ms ease;
    }
    @keyframes flip-3d {
      0% { transform: rotateY(0deg) scale(1); }
      45% { transform: rotateY(170deg) scale(1.06); }
      70% { transform: rotateY(300deg) scale(1.02); }
      100% { transform: rotateY(360deg) scale(1); }
    }
    .status-bar {
      width: 100%;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 13px;
      color: var(--muted);
      padding: 0 4px;
      padding-bottom: 10px;
    }
    .status-strong { color: #e5e7eb; font-weight: 600; }
    .hint { color: var(--muted); }
    .reset-btn {
      margin-top: 10px;
      padding: 12px 18px;
      border-radius: 10px;
      border: none;
      background: linear-gradient(135deg, #38bdf8, #2563eb);
      color: #f8fafc;
      font-size: 15px;
      cursor: pointer;
      box-shadow: 0 10px 26px rgba(37,99,235,0.35);
      transition: transform 120ms ease, box-shadow 120ms ease;
    }
    .reset-btn:hover { transform: translateY(-2px); box-shadow: 0 12px 30px rgba(37,99,235,0.45); }
    .reset-btn.hidden { display: none; }
    @media (max-width: 1100px) {
      .app { width: 98vw; }
      .cards-row { gap: 10px; }
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>4장의 카드를 조합해 숨겨진 숫자를 찾아보세요.</h1>
    </header>

    <section class="result-area">
      <div id="resultWrapper" class="result-wrapper">
        <div id="resultGrid" class="result-grid" aria-live="polite"></div>
      </div>
    </section>

    <section class="cards-area">
      <div class="status-bar">
        <span class="status-strong">선택한 카드: <span id="selectedCount">0</span> / 4</span>
      </div>
      <div id="cardsRow" class="cards-row"></div>
    </section>

    <button id="resetButton" class="reset-btn hidden">다시 시작하기</button>
  </div>

  <script>
    const CARD_CONFIGS = [
      { id: 'c1', label: '카드 1', coloredIndices: [0, 1, 2, 9, 10, 14], isCorrect: true },
      { id: 'c2', label: '카드 2', coloredIndices: [0, 2, 3, 6, 7, 8], isCorrect: true },
      { id: 'f1', label: '카드 3', coloredIndices: [0, 2, 4, 6, 7, 12, 14], isCorrect: false },
      { id: 'f2', label: '카드 4', coloredIndices: [0, 1, 4, 5, 9, 11, 13], isCorrect: false },
      { id: 'c3', label: '카드 5', coloredIndices: [2, 3, 4, 9, 12, 13], isCorrect: true },
      { id: 'c4', label: '카드 6', coloredIndices: [0, 3, 4, 5, 10, 11], isCorrect: true },
    ];
    const CORRECT_IDS = CARD_CONFIGS.filter(c => c.isCorrect).map(c => c.id);

    const state = {
      selected: new Set(),
      locked: false,
      overlap: Array(15).fill(0),
    };

    const cardsRow = document.getElementById('cardsRow');
    const resultGrid = document.getElementById('resultGrid');
    const resultWrapper = document.getElementById('resultWrapper');
    const resetButton = document.getElementById('resetButton');
    const selectedCountEl = document.getElementById('selectedCount');
    const resultCells = [];
    const cardElements = new Map();

    function buildResultGrid() {
      for (let i = 0; i < 15; i += 1) {
        const cell = document.createElement('div');
        cell.className = 'result-cell';
        cell.dataset.index = i;
        cell.addEventListener('transitionend', (e) => {
          if (e.propertyName === 'opacity' && cell.classList.contains('fading-out')) {
            cell.classList.remove('fading-out');
            cell.style.background = '';
          }
        });
        cell.addEventListener('animationend', (e) => {
          if (e.animationName === 'cell-flash') cell.classList.remove('changed');
        });
        resultCells.push(cell);
        resultGrid.appendChild(cell);
      }
    }

    function buildCard(card) {
      const wrapper = document.createElement('button');
      wrapper.className = 'card';
      wrapper.type = 'button';
      wrapper.dataset.id = card.id;

      const inner = document.createElement('div');
      inner.className = 'card-inner';

      const grid = document.createElement('div');
      grid.className = 'grid';
      for (let i = 0; i < 15; i += 1) {
        const cell = document.createElement('div');
        const isFilled = card.coloredIndices?.includes(i);
        cell.className = 'cell' + (isFilled ? ' filled' : '');
        grid.appendChild(cell);
      }

      const front = document.createElement('div');
      front.className = 'card-face front';
      front.appendChild(grid);

      const back = document.createElement('div');
      back.className = 'card-face back';
      back.innerHTML = `
        <div class="card-back-border"></div>
        <svg class="card-back-star" viewBox="0 0 100 100" fill="none" stroke="currentColor" stroke-width="6">
          <path d="M50 10 L61 38 L90 38 L66 56 L75 84 L50 67 L25 84 L34 56 L10 38 L39 38 Z" />
        </svg>
      `;

      inner.appendChild(front);
      inner.appendChild(back);
      wrapper.appendChild(inner);

      wrapper.addEventListener('click', () => handleCardClick(card.id));
      cardElements.set(card.id, wrapper);
      cardsRow.appendChild(wrapper);
    }

    function buildCards() {
      CARD_CONFIGS.forEach(buildCard);
    }

    function applyOverlapToResult() {
      resultCells.forEach((cell, idx) => {
        const count = state.overlap[idx];
        const isOdd = count % 2 === 1;
        const wasOn = cell.classList.contains('on') || cell.classList.contains('on-final');
        const willOn = isOdd;
        const willFinal = isOdd && state.locked;

        if (wasOn && !willOn) {
          const wasFinal = cell.classList.contains('on-final');
          cell.style.background = wasFinal
            ? 'linear-gradient(145deg, rgba(34,197,94,0.9), rgba(22,163,74,0.85))'
            : 'linear-gradient(145deg, rgba(96,165,250,0.8), rgba(56,189,248,0.85))';
          cell.classList.add('fading-out');
        } else {
          cell.classList.remove('fading-out');
          cell.style.background = '';
        }

        cell.classList.toggle('on', isOdd && !state.locked);
        cell.classList.toggle('on-final', willFinal);

        if (wasOn !== willOn) {
          cell.classList.remove('changed');
          void cell.offsetWidth;
          cell.classList.add('changed');
        }
      });
    }

    function updateResult() {
      state.overlap = Array(15).fill(0);
      state.selected.forEach((id) => {
        const card = CARD_CONFIGS.find(c => c.id === id);
        if (card) card.coloredIndices.forEach(idx => { state.overlap[idx] += 1; });
      });
      applyOverlapToResult();
      selectedCountEl.textContent = state.selected.size;
    }

    function updateSelectionHighlights() {
      const isFour = state.selected.size === 4;
      const isAllCorrect = isFour && CORRECT_IDS.every(id => state.selected.has(id));
      cardElements.forEach((el, id) => {
        el.classList.remove('selected-wrong');
        if (state.selected.has(id) && isFour && !isAllCorrect) {
          el.classList.add('selected-wrong');
        }
      });
      return isAllCorrect;
    }

    function playSelectAnimation(cardEl) {
      const inner = cardEl.querySelector('.card-inner');
      if (!inner) return;
      inner.classList.remove('animate');
      cardEl.classList.add('hide-border', 'flip-surface');
      // Force reflow to restart animation
      void inner.offsetWidth;
      const handleEnd = () => {
        cardEl.classList.remove('hide-border', 'flip-surface');
        inner.classList.remove('animate');
      };
      inner.addEventListener('animationend', handleEnd, { once: true });
      inner.classList.add('animate');
    }

    function handleCardClick(id) {
      if (state.locked) return;
      const cardEl = cardElements.get(id);
      const isSelected = state.selected.has(id);

      if (isSelected) {
        state.selected.delete(id);
        cardEl.classList.remove('selected');
        updateResult();
        updateSelectionHighlights();
        return;
      }

      if (state.selected.size >= 4) return;

      state.selected.add(id);
      playSelectAnimation(cardEl);
      cardEl.classList.add('selected');
      updateResult();
      const isWin = checkForWin();
      if (!isWin) updateSelectionHighlights();
    }

    function checkForWin() {
      if (state.selected.size !== CORRECT_IDS.length) return false;
      const isAllCorrect = CORRECT_IDS.every(id => state.selected.has(id));
      if (!isAllCorrect) return false;

      state.locked = true;
      resultWrapper.classList.add('success');
      cardsRow.querySelectorAll('.card').forEach(c => c.classList.add('disabled'));
      applyOverlapToResult();

      setTimeout(() => {
        resetButton.classList.remove('hidden');
      }, 3000);
      return true;
    }

    function resetGame() {
      state.selected.clear();
      state.locked = false;
      state.overlap = Array(15).fill(0);
      cardElements.forEach((el) => {
        el.classList.remove('selected', 'disabled', 'animate', 'selected-wrong');
      });
      resultWrapper.classList.remove('success');
      resetButton.classList.add('hidden');
      updateResult();
      updateSelectionHighlights();
    }

    function init() {
      buildResultGrid();
      buildCards();
      updateResult();
      resetButton.addEventListener('click', resetGame);
    }

    init();
  </script>
</body>
</html>

